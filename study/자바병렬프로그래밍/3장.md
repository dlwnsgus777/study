### 3장 객체 공유
---

여러 개의 스레드에서 특정 객체를 동시에 사용하려 할 때 섞이지 않고 안전하게 동작하도록 객체를 공유하고 공개하는 방법을 살펴본다.

특정 변수의 값을 사용하고 있을 때 다른 스레드가 해당 변수의 값을 사용하지 못하도록 막아야 할 뿐아니라,
값을 사용한 다음 동기화 블록을 빠져나가고 나면 다른 스레드에서 변경된 값을 즉시 사용할 수 있게 해야한다.

## 가시성

- 스레드에서의 가시성
  - `한 스레드에서 변경한 값이 다른 스에드에서 보이는가?` 의 개념

특정 변수의 값을 가져갈 때 다른 스레드가 작성한 값을 가져갈 수 있다는 보장이 없고, 값을 읽지 못할 수도 있기 때문에

**메모리상의 공유된 변수를 여러 스레드에서 서로 사용할 수 있게 하려면 반드시 동기화 기능을 구현해야한다.**

재배치 현상은 특정 메서드의 소스코드가 100% 코딩된 순서로 동작한다는 점을 보장할 수 없는 현상이다.

때문에 동기화 기능을 지정하지 않으면 컴파일러나 프로세서, JVM 등이 프로그램 코드가 실행되는 순서를 임의로 바꿔 실행하는 이상한 경우가 발생하기도 한다.

## 스테일 데이터

- 스테일 데이터
  - 이미 변경되었지만 여전히 오래된 값을 읽고 있는 상태

어떤 변수에서건 스테일 현상이 발생하면 예기치 못한 예외 상황이 발생하고, 무한 반복에 빠져들 수도 있다.


```java
public class MutableInteger {
    
   private int value;
   
   public int get() {
       return value;
   }
   
   public synchronized void set(int value) {
       this.value = value;
   }
}
```

위의 코드는 set을 동기화 했지만 get 메서드가 동기화 되어있지 않기 때문에 여전히 스테일 상황을 초래할 수 있다.

## 단일하지 않은 64 비트 연산

스테일 상태의 값을 읽어가도 전혀 엉뚱한 값을 가져가는 것이 아닌 예전의 데이터를 가져가기 때문에 전혀 난데없는 값이 생기지는 않는다.

64비트를 사용하는 숫자형 (long, double) 에 volatile 키워드가 없는 경우 난데없는 값이 발생할 가능성이 있다.

volatile 키워드를 사용하지 않는 long이나 double 의 64비트 값에 대해 메모리에서 쓰거나 읽을 때 두 번의 32비트 연선알 사용하도록 하용하고 있다.

Java 5부터는 명확한 자바 메모리 모델(JMM) 이 도입되면서 아래와 같이 변경되었습니다.

long과 double 타입의 읽기/쓰기는 atomic이어야 한다, 단 다음 조건을 만족할 경우에만 예외 없이 안전하다:
	•	변수가 volatile로 선언되었거나
	•	JVM이 64비트 아키텍처에서 실행 중이며, 해당 플랫폼이 64비트 정렬을 지원하는 경우

즉, Java 5 이후부터 대부분의 JVM에서는 아래와 같은 조건에서 long/double은 안전하게 원자적으로 처리된다.

다만 JLS에서는 명시적으로 보장하고 있지 않기 때문에 여전히 주의해야한다.

## 락과 가시성

synchronized로 둘러싸인 코드에서 스레드 A가 사용했던 모든 변수의 값은, 같은 락을 사용하는 synchronized로 둘러싸인 코드를

스레드 B가 실행할 때 안전하게 사용할 수 있다.

값을 변경할 수 있는 변수를 여러 개의 스레드에서 동시에 사용한다면 바로 이전 스레드에서 사용했던 변수의 값이 오류 없이 정상적으로 다음 스레드가 사용할 수 있도록

동일한 락을 사용하는 synchronized 블록으로 막아줄 필요가 있다.

```java
class Counter { // -> lock이 같은 객체
    private int count = 0;
    private final Object lock = new Object();

    public void increment() {
        synchronized (lock) {
            count++;
        }
    }

    public int get() {
        synchronized (lock) {
            return count;
        }
    }
}

public void increment() {
    synchronized (new Object()) {
        count++;  // 잘못된 예!
    }
}
```

여러 스레드가 공유해 사용하는 변수를 각 스레드에서 각자 최신의 정상적인 값으로 활용하려면 동일한 락을 사용해 모두 동기화 시켜야 한다.


## volatile 변수

volatile로 선언된 변수의 값을 바꿨을 때 다른 스레드에서 항상 최신 값을 읽어갈 수 있게 해준다.

volatile 키워드를 사용하면 실행 순서가 재배치 되지 않으며 프로세서의 레지스터에 캐시되지 않고 프로세서 외부의 캐시에도 들어가지 않는다.

때문에 volatile 변수의 값을 읽으면 항상 최신의 값을 읽어갈 수 있다.

volatile 을 사용하면 아무런 락이나 동기화 기능이 동작하지 않기 때문에 synchronized 보다는 강도가 약할 수 밖에 없다.

volatile 변수를 사용하는 적절한 경우는 일반적으로 변수에 보관된 클래스의 상태에 대한 가시성을 확보하거나 중요한 이벤트가 발생했다는 등의 정보를 정확하게 전달하고자 하는 경우다.

락을 사용하면 가시성과 연산의 단일성을 모두 보장받을 수 있다.

volatile 변수는 연산의 단일성은 보장하지 못하고 가시성만 보장한다.

- 연산의 단일성
  - 어떤 연산이 쪼개지지 않고 완전하게 실행되는 것을 의미
 
락을 사용하면 한 번에 하나의 스레드만 코드 블록에 진입 가능하기 때문에 연산이 쪼개져 있어도 다른 스레드가 끼어들지 못한다.

때문에 복합 연산도 원자적으로 수행된 것처럼 보이게된다.


## 공개와 유출

특정 객체를 현재 코드의 스코프 범위 밖에서 사용할 수 있도록 만들면 공개되었다고 한다.

만약 클래스 내부의 상태 변수를 외부에 공개해야 한다면 객체 캡슐화 작업이 물거품이 되거나 내부 데이터의 안전성을 해칠 수 있다.

의도적으로 공개시키지 않았지만 외부에서 사용할 수 있게 공개된 경우를 유출 상태라고 한다.

특정 객체 하나를 공개한다고 해도, 그와 관련된 다른 객체까지 덩달아 공개하게 되는 경우도 있다.

```java
class UnsafeStates {
    private String[] states = new String[] {
        "A", "B"...
    }
    
    public String[] getStates() {
        return states;
    }
}

```
getStates 를 호출해 private 변수로 선언된 states 변수를 가져올 수 있다.

어떤 객체 건 일단 유출되고 나면 다른 스레드가 유출된 클래스를 의도적이건 의도적이지 않건 반드시 잘못 사용할 수 있다고 가정해야 한다.

또다른 경우는 내부 클래스의 인스턴스를 외부에 공개하는 것이다.

내부 믈래스는 항상 부모 클래스에 대한 참조를 갖고 있는다.

```java
import java.util.EventListener;

public class ThisEscape {
  public ThisEscape(EventSource source) {
    source.registerListener(
            new EventListener() {
                public void onEvent(Event e) {
                    doSomething(e);
                }
            }
    );
  }
}

```
이 코드의 문제점은 this가 완전히 초기화되기 전에 외부로 노출되고 있다는 점이다.

	•	EventListener는 익명 내부 클래스이므로,
	•	ThisEscape 인스턴스에 자동으로 연결된 this 참조를 갖고 있음
	•	그런데 이 리스너는 source.registerListener(...)를 통해 외부에 등록됨
	•	즉, 외부 객체(source)가 ThisEscape의 내부 인스턴스(this)를 너무 일찍 보게 되는 것

이런 경우, 외부 스레드가 onEvent()를 호출하면 ThisEscape 객체는 아직 생성자에서 초기화 중일 수도 있다.
→ 그러면 필드가 아직 초기화되지 않았거나, 일관성이 깨진 상태일 수도 있음


## 생성 메소드 안전성

생성 메서드가 실행되는 도중에 해당 객체를 외부에 공개한다면 정상적이지 않은 상태의 객체를 외부에서 불러 사용할 가능성이 있다.

때문에 생성 메서드를 실행하는 도중에는 this 변수가 외부에 유출되지 않게 해야한다.

생성 메서드에서 또 다른 스레드를 만들어 내면 대부분의 경우에는 생성 메서드의 클래스와 새로운 스레드가 this 변수를 직접 공유하거나 자동으로 공유되기도 한다.

필요한 경우에 생성 메서드에서 스래드를 **생성** 하는 건 별 문제가 없지만 생성과 동시에 **시작** 시키는 건 문제의 소지가 많다.

생성 메서드에서 새로운 스레드를 시작시키리면 생성 메서드를 private 으로 지정하고 public으로 지정된 팩토리 메서드를 만들어 사용하는 방식이 좋다.

## 스레드 한정

변경 가능한 객체를 공유해 사용하는 경우에는 항상 동기화시켜야 한다.

특정 객체를 단일 스레드에서만 사용한다고 확신할 수 있다면 해당 객체는 따로 동기화할 필요가 없다.

객체를 사용하는 스레드를 한정하는 방법으로 스레드 안전성을 확보할 수 있다.

## 스택 한정

스택 한정 기법은 특정 객체를 로컬 변수를 통해서만 사용할 수 있는 특별한 경우의 스레드 한정 기법이다.

로컬 변수는 현재 실행 중인 스레드 내부의 스택에만 존재하기 때문에 스레드 내부의 스택은 외부 스레드에서 볼 수 없다.

```java
public void process() {
    StringBuilder sb = new StringBuilder(); // 스레드 한정
    sb.append("Hello");
    sb.append("World");
    System.out.println(sb.toString());
}
```
	•	StringBuilder는 스레드 안전하지 않은 클래스이지만,
	•	위와 같이 지역 변수로만 사용하면 → 스레드끼리 공유하지 않음 → 안전함

## ThreadLocal

스레드 내부의 값과 값을 갖고 있는 객체를 연결해 스레드 한정 기법을 적용할 수 있도록 도와주는 좀더 형식적인 방법으로 ThreadLocal이 있다.

ThreadLocal 클래스의 get 메서드를 호출하면 현제 실행 중인 스레드에서 최근에 set 메서드를 호출해 저장했던 값을 가져올 수 있다.

스레드 로컬  변수는 변경 가능한 싱글턴이나 지역 변수 등을 기반으로 설계되어 있는 구조에서 변수가 임의로 공유되는 상황을 막기 위해 사용하는 경우가 많다.

스레드별 값은 실제로 Thread 객체 자체에 저장되어 있으며, 스레드가 종료되면 스레드별 값으로 할당되어 있던 부분도 가비지 컬렉터가 처리한다.

전역 변수가 아니더라도 전역 변수처럼 동작하기 떄문에 프로그램 구조상 전역 변수를 남발하는 결과를 가져올 수도 있고, 메서드에 인자로 넘겨야할 값을 

ThreadLocal을 통해 뒤로 넘겨주는 방법을 사용하면서 프로그램의 구조가 허약해질 가능성도 높다.


## 불변성

불변 객체는 직접적으로 객체를 동기화하지 않고도 안전하게 사용할 수 있는 방법이다.

불변 객체는 맨 처음 생성되는 시점을 제외하고는 그 값이 전혀 바뀌지 않는 객체를 말한다.

**불변 객체는 언제라도 스레드에 안전하다.**

다음 조건을 만족하면 해당 객체는 불변 객체다.
- 생성되고 난 이후에는 객체의 상태를 변경할 수 없다.
- 내부의 모든 변수는 final로 설정돼야 한다.
  - 기술적으로 보면 모든 변수를 final로 선언하지 않아도 충분히 불변 객체를 만들 수 있다.
- 적절한 방법으로 생성돼야 한다.(this 변수에 대한 참조가 외부로 유출되지 않아야한다.)

데이터가 불변 객체에 들어있다 해도, 해당 객체를 가리키고 있는 참조 변수에 또 다른 불변 객체를 바꿔치기하면 프로그램의 데이터가 언제든지 바뀔 수 있다.

## final 변수

final 키워드를 적절하게 사용하면 초기화 안전성을 보장하기 때문에 별다른 동기화 작업 없이도 불변 객체를 자유롭게 사용하고 공유할 수 있다.
 
나중에 변경할 일이 없다고 판단되는 변수는 final로 선언해두는 것도 좋은 방법이다.

서로 관련되어 있는 여러 개의 변수값을 서로 읽거나 쓰는 과정에 경쟁 조건이 발생할 수 있는데 불변 객체에 변수를 묶어두면 특정 스레드가 불변 객체를 사용할 때 다른 스레드가 불변 객체 값을 변경하지 않을까 걱정하지 않아도 된다.

```java
@ThreadSafe
public class VolatileCachedFactorizer implements Servlet {
    private volatile oneValueCache cache = new OneValueCache(null,null);

    public void service(ServletRequest req, ServletResponse resp){
        BigInteger i = extractFromRequest(req);
        Biginteger[] factors = cache.getFactors(i);

        if(factors == null){
            factors = factor(i);
            cache = new OneValueCache(i, factors);
        }

        encodeIntoResponse(resp, factors);
    }
}
```
위의 예제처럼 불변 객체를 공개할 때 volatile을 사용하면 시간적으로 가시성성을 확보하기 때문에 따로 락을 사용하지 않았다 해도 스레드에 안전하다.

## 안전 공개

여러 스레드에서 공유하도록 공개해야하는 상황에서는 반드시 안전한 방법을 사용해야 한다.

```java
public Holder holder;

public void initialize() {
    holder = new Holder(42);
}
```
위의 코드처럼 단순한 방법으로 객체를 외부에 공개하면 생성 메서드가 채 끝나기도 전에 공개된 객체를 다른 스레드가 사용할 수 있다.

## 불변 객체와 초기화 안전성

자바 메모리 모델에는 불면 객체를 공유하고자 할 때 초기화 작업을 안전하게 처리할 수 있는 방법이 만들어져 있다.

불변 객체는 별다른 동기화 방법을 적용하지 않았다 해도, 어느 스레드에서건 마음껏 안전하게 사용할 수 있다.

불면 객체를 공개하는 부분에 동기화 처리를 하지 않았다 해도 아무런 문제가 없다.

final로 선언된 모든 변수는 별다른 동기화 작업 없이도 안전하게 사용할 수 있다.

하지만 final로 선언된 변수에 변경 가능한 객체가 지정되어 있다면 해당 변수에 들어 있는 객체의 값을 사용하려고 하는 부분을 모두 동기화시켜야 한다.

## 안전한 공개 방법의 특성

객체를 안전하게 공개하려면 해당 객체에 대한 참조와 객체 내부의 상태를 외부의 스레드에게 동시에 볼 수 있어야 한다.

올바르게 생성 메서드가 실행되고 난 객체는 다음과 같은 방법으로 안전하게 공개할 수 있다.
- 객체에 대한 참조를 static 메서드에서 초기화 시킨다.
- 객체에 대한 참조를 volatile 변수 또는 AtomicReference 클래스에 보관한다.
- 객체에 대한 참조를 올바르게 생성된 클래스 내부의 final 변수에 보관한다.
- 락을 사용해 올바르게 막혀 있는 변수에 객체에 대한 참조를 보관한다.

자바에서 기본으로 제공하는 스레드 안전한 컬렉션은 다음과 같은 스레드 동기화 기능을 갖고 있다.

- `HashTable`, `ConcurrentMap`, `synchronizedMap` 을 사용해 만든 Map 객체를 사용하면 그 안에 보관하고 있는 키와 값 모두를 어느 스레드에서라도 항상 안전하게 사용할 수 있다.
- 객체를 `Vector`, `CopyOnWriteArrayList`, `CopyOnWriteArraySet` 이나 `synchronizedList` 또는 `synchronizedSet` 메서드로 만든 컬렉션은 그 안에 보관하고 있는 객체를 어느 스레드에서라도 항상 안전하게 사용할 수 있다.
- `BlockingQueue` 나 `ConcurrentLinkedQueue` 컬렉션에 들어 있는 객체는 어느 스레드라도 항상 안전하게 사용할 수 있다.

다음과 같이 static 변수를 선언할 때 직접 new 연산자로 생성 메서드를 실행해 객체를 생성할 수 있다면 안전한 객체 공개 방법이다.

```java
public static Holder holder = new Holder(42);
```
위 방법은 JVM에서 클래스를 초기화하는 시점에 작업이 모두 진행된다.

## 결과적으로 불변인 객체

특정 객체가 불변일 수 없다고 해도, 한 번 공개된 이후에는 그 내용이 변경되지 않는다고 하면 결과론적으로 봤을 때 해당 객체도 불변 객체라고 할 수 있다.


