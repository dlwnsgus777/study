## 람다 표현식

---

### 람다란 무엇인가?

**람다 표현식**은 메서드로 전달할 수 있는 익명 함수를 단순화한 것이다.

람다의 특징은 다음과 같다.

- 익명: 이름이 없으므로 익명이라 표현한다.
- 함수: 특정 클래스에 종속되지 않으므로 함수라고 부른다.
- 전달: 메서드 인수로 전달하거나 변수로 저장할 수 있다.
- 간결성: 익명 클래스처럼 자질구레한 코드를 구현할 필요가 없다.

엄밀히 말해 람다가 기술적으로 자바 8 이전의 자바로 할 수 없었던 일을 제공하는 것은 아니다.

### 람다 표현식

람다 표현식은 다음 세가지로 이루어진다.

- 파라미터 리스트
- 화살표
- 람다 바디

```java
// 파라미터 리스트 -> 람다 바디
// 의 형식이다.
(Apple a1, Apple a2) -> a1.getWeight().compareTo(a2.getWeight());
```

람다에는 두가지 스타일이 있다.

- 표현식 스타일 : (parameters) -> expression
- 블록 스타일 : (parameters) -> { statements; }

### 어디에 어떻게 사용할끼?

람다는 **함수형 인터페이스** 를 기대하는 인수에 사용할 수 있다.

### 함수형 인터페이스

하나의 추상 메서드를 지정하는 인터페이스를 **함수형 인터페이스** 라고 한다.

```java
// 하나의 추상메서드만 가지고 있는 인터페이스
public interface Predicate<T> {
	boolean test(T t);
}
```

만약 **디폴트 메서드** 가 여러개 있더라도 **추상 메서드가 오직 하나** 라면 함수형 인터페이스이다.

람다 표현식으로 함수형 인터페이스의 추상 메서드 구현을 직접 전달할 수 있고 **전체 표현식을 함수형 인터페이스의 인스턴스로 취급**할 수 있다.

### 함수 디스크립터

함수형 인터페이스의 **추상 메서드 시그니처** 는 람다 표현식의 시그니처를 가리킨다.

이 시그니처를 서술하는 메서드를 **함수 디스크립터** 라고 부른다.

```java
() -> void
```

위는 파라미터가 없고 void 를 반환하는 함수 디스크립터이다.

```java
public void process(Runnable r) {
	r.run();
}

process(() -> System.out.println("This is awesome!"))
```

위의 코드에서 Runnable 인터페이스의 `run()` 와 람다 표현식의 시그니처는 같다.

`@FunctionalInterface` 를 인터페이스에 사용하면 **함수형 인터페이스가 아니면 컴파일 에러를 발생시킨다.**

### 함수형 인터페이스 사용

#### 기본형 특화

자바의 모든 형식은 참조형과 기본형에 해당한다.

기본형을 참조형으로 변환하는 것을 **박싱**

참조형을 기본형으로 변환하는 것을 **언박싱** 이라고한다.

자바에서는 이 과정을 자동으로 이루어지게 **오토 박싱** 이라는 기능을 제공한다.

이떄 변환하는 과정에는 비용이 들어가게된다.

즉, `<T>` 에서 T 는 참조형만 가능하기 때문에

기본형을 받기 위핸 인터페이스를 따로 정의해야한다.

```java
public interface IntPredicate {
	boolean test(int t);
}
```

### 예외, 람다, 함수형 인터페이스의 관계

함수형 인터페이스는 **확인된 예외를 던지는 동작을 허용하지 않는다.**

예외를 던지는 람다 표현식을 만들려면 예외를 선언하는 함수형 인터페이스를 직접 정의하거나 람다를 `try/catch` 블럭으로 감싸야한다.

### 형식 검사, 형식 추론, 제약

람다가 전달될 메서드 파라미터나 람다가 할당되는 변수 등에서 기대되는 람다 표현식의 형식을 **대상 형식** 이라고 한다.

```java
List<Apple> heavierThan150g =
	filter(inventory, (Apple apple) - apple.getWeight() > 150);
```

위의 메서드에서는 다음 순서로 형식 확인 과정이 진행된다.

1. filter 메서드의 선언을 확인
2. filter 메서드에서 두번째 파라미터로 `Predicate<Apple>` 형식을 기대한다(대상형식)
3. `Predicate<Apple>` 는 `test` 라는 한개의 추상 메서드를 가지고 있는 함수형 인터페이스이다.
4. `test` 의 함수 디스크립터는 `Apple` 을 받아 `boolean` 을 리턴한다.
5. filter 로 전달된 람다의 시그니처는 이를 만족하므로 형식 검사가 성공적으로 완료된다.

### 같은 람다, 다른 함수형 인터페이스

**대상 형식** 이라는 특징 때문에 같은 람다 표현식이라도 호환되는 추상 메서드를 가진 다른 함수형 인터페이스로 사용될 수 있다.

람다의 바디에 일반 표현식이 있으면 `void` 를 반환하는 함수 디스크립터와 호환된다.

```java
Predicate<String> p = s -> list.add(S);

Consumer<String> b = s -> list.add(S);
```

`list` 의 `add` 는 `boolean` 을 반환하지만 `Consumer` 로 사용할 수 있다.

같은 함수형 디스크립터라면 **캐스트** 를 사용해 누구를 호출할지 명확하게 할 수 있다.

```java
excute((Action) () -> {});
```

### 형식 추론

자바 컴파일러는 람다 표현식이 사용된 콘텍스트를 이용해 람다 표현식과 관련된 함수형 인터페이스를 추론한다.

대상 형식을 이용해 함수 디스크립터를 알 수 있으므로 컴파일러는 람다의 시그니처도 추론할 수 있다.

```java
List<Apple> redApples = filterApples(inventory, (Apple apple) -> Color.RED.equals(apple.getColor()));
```

위와 같은 코드를

```java
List<Apple> redApples = filterApples(inventory,  apple -> Color.RED.equals(apple.getColor()));
```

이렇게 줄일 수 있다.

### 지역 변수 사용

람다 표현식에서는 익명 함수가 하는 것처럼 **지역 변수** 를 활용할 수 있다.

이를 **람다 캡처링** 이라고 부른다.

```java
int portNumber = 1337;
Runnable r = () -> System.out.println(portNumber);
```

람다는 인스턴스 변수와 정적 변수를 자유롭게 캡처 (자신의 바디에서 참조) 할 수 있지만 **지역 변수는 명시적으로**
`final` 로 선언된 변수와 똑같이 사용되어야 한다.

즉, 한 번만 할당할 수 있는 지역 변수는 캡처링할 수 있다.

```java
int portNumber = 1337;
Runnable r = () -> System.out.println(portNumber);
portNumber = 8080;
```

위의 코드는 지역 변수인 `portNumber` 에 값을 **두 번 할당** 하므로 컴파일할 수 없는 코드가 된다.

### 지역 변수의 제약

인스턴스 변수는 **힙** 에 저장되지만 지역 변수는 **스택** 에 위치한다.

람다가 스레드에서 실행된다면 변수를 할당한 스레드가 사라져서 변수 할당이 해제되었는데도 람다를 실행하는 스레드에서는 해당 변수에 접근하려 할 수 있기 때문에 이러한 제약이 생긴 것이다.

정확하게는 지역 변수의 **복사본** 을 제공하는 것이고 복사본의 값이 바뀌지 않아야하기 때문에 한 번만 할당해야 한다는 제약이 생긴 것이다.

### 클로저

클로저란 함수의 비지역 변수를 자유롭게 참조할 수 있는 함수의 인스턴스를 가르킨다.

클로저를 다른 함수의 인수로 전달할 수 있다.

클로저는 외부에 정의된 변수의 값에 접근하고 값을 바꿀 수 있다.

자바 8의 람다도 이와 비슷한 동작을 수행한다.

람다와 익명 클래스 모두 **인수로 전달될 수 있으며**

**자신의 외부 영역의 변수에 접근할 수 있다.**

하지만 **람다가 정의된 메서드의 지역 변수의 값은 바꿀 수 없다.**

이는 안전하지 않은 동작을 수행할 가능성을 낮춰준다.

인스턴스 변수는 스레드가 공유하는 **힙** 에 존재하므로 특별한 제약이 없다.

### 메서드 참조

메서드 참조를 이용하면 기존의 메서드 정의를 재활용해 람다처럼 전달할 수 있다.

메서드 참조를 사용하는 것이 때에 따라 가독성이 더 좋을 수 있다.

```java
inventory.sort((Apple a1, Apple a2) -> a1.getWeight().compareTo(a2.getWeight()));
```

위의 기존 코드를

```java
inventory.sort(comparing(Apple::getWeight));
```

메서드 참조를 이용해 줄일 수 있다.

### 요약

메서드 참조는 명시적으로 메서드명을 참조함으로써 가독성을 높일 수 있다.

메서드 참조는 메서드명 앞에 구분자 (`::` ) 를 붙이는 방식으로 참조할 수 있다.

`Apple::getWeight` 는 람다 표현식 `(Apple a) -> a.getWeight()` 를 축약한 것이다.

### 메서드 참조를 만드는 방법

메서드 참조는 세 가지 유형으로 구분할 수 있다.

- 정적 메서드 참조
  - Integer 의 parseInt 메서드는 `Integer::parseInt` 로 표현할 수 있다.
- 다양한 형식의 인스턴스 메서드 참조
  - String 의 length 메서드는 `String::length` 로 표현할 수 있다.
- 기존 객체의 인스턴스 메서드 참조
  - transaction 인스턴스에 getValue 메서드가 있다면 `transaction::getValue` 로 표현할 수 있다.

컴파일러는 람다 표현식을 검사하던 방식과 비슷한 과정으로 메서드 참조가 주어진 함수형 인터페이스와 호환하는지 확인한다.

**메서드 참조는 콘텍스트의 형식과 일치해야한다.**

### 생성자 참조

`ClassName::new` 처럼 클래스명과 `new` 키워드를 이용해 기존 생성자의 참조를 만들 수 있다.

`ClassName::new` 는 인수가 없는 생성자를 의미하며 `Supplier` 의 `() -> Apple` 과 같은 시그니처를 갖는다.

```java
Supplier<Apple> c1 = Apple::new
Apple a1 = c1.get();
```

위처럼 생성자를 메서드 참조로 사용할 수 있다.

인수를 하나 전달받는 생성자를 참조하려면 `Function<T, R>` 을 사용하면 된다.

```java
Function<Integer, Apple> c2 = Apple::new;
Apple a2 = c2.apply(110);
```

위의 코드처럼 사용하면된다.

만약 여러개의 인수를 받는 생성자를 사용하고 싶다면 해당 생성자와 일치하는 시그니처를 가지는 인터페이스를 직접 정의해 사용하면 된다.

```java
public interface TriFunction<T, U, V, R> {
	R apply(T t, U u, V v);
}

TriFunction<Integer, Integer, Integer, Color> colorFactory = Color::new;
```
