## 람다 표현식

---

### 람다란 무엇인가?

**람다 표현식**은 메서드로 전달할 수 있는 익명 함수를 단순화한 것이다.

람다의 특징은 다음과 같다.

- 익명: 이름이 없으므로 익명이라 표현한다.
- 함수: 특정 클래스에 종속되지 않으므로 함수라고 부른다.
- 전달: 메서드 인수로 전달하거나 변수로 저장할 수 있다.
- 간결성: 익명 클래스처럼 자질구레한 코드를 구현할 필요가 없다.

엄밀히 말해 람다가 기술적으로 자바 8 이전의 자바로 할 수 없었던 일을 제공하는 것은 아니다.

### 람다 표현식

람다 표현식은 다음 세가지로 이루어진다.

- 파라미터 리스트
- 화살표
- 람다 바디

```java
// 파라미터 리스트 -> 람다 바디
// 의 형식이다.
(Apple a1, Apple a2) -> a1.getWeight().compareTo(a2.getWeight());
```

람다에는 두가지 스타일이 있다.

- 표현식 스타일 : (parameters) -> expression
- 블록 스타일 : (parameters) -> { statements; }

### 어디에 어떻게 사용할끼?

람다는 **함수형 인터페이스** 를 기대하는 인수에 사용할 수 있다.

### 함수형 인터페이스

하나의 추상 메서드를 지정하는 인터페이스를 **함수형 인터페이스** 라고 한다.

```java
// 하나의 추상메서드만 가지고 있는 인터페이스
public interface Predicate<T> {
	boolean test(T t);
}
```

만약 **디폴트 메서드** 가 여러개 있더라도 **추상 메서드가 오직 하나** 라면 함수형 인터페이스이다.

람다 표현식으로 함수형 인터페이스의 추상 메서드 구현을 직접 전달할 수 있고 **전체 표현식을 함수형 인터페이스의 인스턴스로 취급**할 수 있다.

### 함수 디스크립터

함수형 인터페이스의 **추상 메서드 시그니처** 는 람다 표현식의 시그니처를 가리킨다.

이 시그니처를 서술하는 메서드를 **함수 디스크립터** 라고 부른다.

```java
() -> void
```

위는 파라미터가 없고 void 를 반환하는 함수 디스크립터이다.

```java
public void process(Runnable r) {
	r.run();
}

process(() -> System.out.println("This is awesome!"))
```

위의 코드에서 Runnable 인터페이스의 `run()` 와 람다 표현식의 시그니처는 같다.

`@FunctionalInterface` 를 인터페이스에 사용하면 **함수형 인터페이스가 아니면 컴파일 에러를 발생시킨다.**

### 함수형 인터페이스 사용

#### 기본형 특화

자바의 모든 형식은 참조형과 기본형에 해당한다.

기본형을 참조형으로 변환하는 것을 **박싱**

참조형을 기본형으로 변환하는 것을 **언박싱** 이라고한다.

자바에서는 이 과정을 자동으로 이루어지게 **오토 박싱** 이라는 기능을 제공한다.

이떄 변환하는 과정에는 비용이 들어가게된다.

즉, `<T>` 에서 T 는 참조형만 가능하기 때문에

기본형을 받기 위핸 인터페이스를 따로 정의해야한다.

```java
public interface IntPredicate {
	boolean test(int t);
}
```

### 예외, 람다, 함수형 인터페이스의 관계

함수형 인터페이스는 **확인된 예외를 던지는 동작을 허용하지 않는다.**

예외를 던지는 람다 표현식을 만들려면 예외를 선언하는 함수형 인터페이스를 직접 정의하거나 람다를 `try/catch` 블럭으로 감싸야한다.

### 형식 검사, 형식 추론, 제약

람다가 전달될 메서드 파라미터나 람다가 할당되는 변수 등에서 기대되는 람다 표현식의 형식을 **대상 형식** 이라고 한다.

```java
List<Apple> heavierThan150g =
	filter(inventory, (Apple apple) - apple.getWeight() > 150);
```

위의 메서드에서는 다음 순서로 형식 확인 과정이 진행된다.

1. filter 메서드의 선언을 확인
2. filter 메서드에서 두번째 파라미터로 `Predicate<Apple>` 형식을 기대한다(대상형식)
3. `Predicate<Apple>` 는 `test` 라는 한개의 추상 메서드를 가지고 있는 함수형 인터페이스이다.
4. `test` 의 함수 디스크립터는 `Apple` 을 받아 `boolean` 을 리턴한다.
5. filter 로 전달된 람다의 시그니처는 이를 만족하므로 형식 검사가 성공적으로 완료된다.

### 같은 람다, 다른 함수형 인터페이스

**대상 형식** 이라는 특징 때문에 같은 람다 표현식이라도 호환되는 추상 메서드를 가진 다른 함수형 인터페이스로 사용될 수 있다.

람다의 바디에 일반 표현식이 있으면 `void` 를 반환하는 함수 디스크립터와 호환된다.

```java
Predicate<String> p = s -> list.add(S);

Consumer<String> b = s -> list.add(S);
```

`list` 의 `add` 는 `boolean` 을 반환하지만 `Consumer` 로 사용할 수 있다.

같은 함수형 디스크립터라면 **캐스트** 를 사용해 누구를 호출할지 명확하게 할 수 있다.

```java
excute((Action) () -> {});
```
