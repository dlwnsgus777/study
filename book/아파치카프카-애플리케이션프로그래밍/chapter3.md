## 카프카 기본 개념 설명

---

### 카프카 브로커 . 클러스터 . 주키퍼

카프카 브로커는 카프카 클라이언트와 데이터를 주고받기 위해 사용하는 주체이자, 데이터를 분산 저장하여 장애가 발생하더라도 안전하게 사용할 수 있도록 도와주는 애플리케이션이다.

하나의 서버에는 한 개의 카프카 브로커 프로세스가 실행된다.

보통 브로커 서버 1대로도 실행이 가능하지만 데이터를 안전하게 보관하기 위해서 3대 이상의 브로커 서버를 1개의 **클러스터**로 묶어 운영한다.

클러스터로 묶인 브로커들은 프로듀서가 보낸 데이터를 안전하게 분산 저장하고 복제하는 역할을 수행한다.

### 데이터 저장, 전송

프로듀서로부터 데이터를 전달받으면 카프카브로커는 프로듀서가 요청한 토픽의 파티션에 데이터를 저장하고, 컨슈머가 데이터를 요청하면 파티션에 저장된 데이터를 전달한다.

**프로듀서로부터 전달된 데이터는 파일시스템에 저장된다.**

카프카는 **페이지 캐시**를 사용하여 디스크 입출력 속도를 높인다.

페이지 캐시란 **OS에서 파일 입출력의 성능 향상을 위해 만들어 놓은 메모리 영역**이다.

한번 읽은 파일의 내용은 메모리의 페이지 캐시 영역에 저장되고 나중에 동일한 파일의 접근이 일어나면 메모리에서 직접 읽는 방식이다.

페이지 캐시를 이용하지 않으면 **JVM** 위에서 동작하는 카프카 브로커에서 빠른 속도를 기대하기 어려웠을 것이다.

이러한 특징 떄문에 카프카 브로커를 실행하는데 **힙 메모리** 사이즈를 크게 설정할 필요가 없다.

### 데이터 복제, 싱크

데이터 복제는 카프카를 장애 허용 시스템으로 동작하도록하는 원동력이다.

클러스터로 묶인 브로커 중 일부에 장애가 발생하더라도 데이터를 유실하지 않고 안전하게 사용할 수 있다.

데이터 복제는 **파티션 단위**로 이루어지고, 토픽 생성시 파티션의 복제 개수도 같이 설정할 수 있다.

최솟값은 1이고 최댓값은 브로커 개수만큼 설정할 수 있다.

복제된 파티션은 **리더**와 **팔로워**로 구성된다.

- 리더: 프로듀서, 컨슈머와 직접 통신하는 파티션
- 팔로워: 복제 데이터를 가지고 있는 파티션

팔로워 파티션들은 리더 파티션의 오프셋을 확인하여 현재 자신이 가지고 있는 오프셋과 차이가 나는 경우 리더 파티션의 데이터를 복제한다.

파티션 복제로인해 복제 개수만큼의 용량이 증가된다는 단점이 있다.

안전하게 사용할 수 있다는 장점 떄문에 카프카 운영시 2 이상의 복제 개수를 정하는 것이 중요하다.

만약 브로커가 다운되면 해당 브로커에 있는 리더 파티션의 지위는 팔로워 파티션 중 하나가 넘겨받는다.

복제 갯수를 3으로 설정한다면 최대 2개의 브로커에서 동시 장애가 발생해도 데이터를 안전하게 유지할 수 있다.

### 컨트롤러

클러스터의 브로커 중 한대가 컨트롤러 역할을 한다.

컨트롤러는 다른 브로커의 상태를 체크하고 브로커가 클러스터에서 빠지는 경우 해당 브로커에 존재하는 리더 파티션을 재분배한다.

컨트롤러 브로커에서 장애가 발생하면 다른 브로커가 컨트롤러 역할을 대신한다.

### 데이터 삭제

카프카는 컨슈머가 데이터를 가져가더라도 토픽의 데이터를 삭제하지 않는다.

컨슈머나 프로듀서가 데이터 삭제를 요청할 수도 없다.

**브로커만이 데이터를 삭제할 수 있다.**

데이터 삭제는 파일 단위로 이루어지고, 이 단위를 **로그 세그먼트**라 부른다.

세그먼트는 특정 데이터를 선별해 삭제할 수 없고, 데이터가 쌓이는 동안 파일 시스템으로 열려있다.

브로커에 `log.segement.bytes` 또는 `log.segement.ms` 값이 설정되면 세그먼트 파일이 닫힌다.

세그먼트 파일이 닫히는 기본값은 `1GB` 용량에 도달했을 때이다.

닫힌 세그먼트 파일은 `log.segement.bytes` 또는 `log.segement.ms` 옵션에 설정값이 넘으면 삭제된다.

닫힌 세그먼트 파일을 체크하는 간격은 `log.retenstion.check.interval.ms` 에 설정된 값에 따른다.

### 컨슈머 오프셋 저장

컨슈머 그룹은 토픽이 특정 파티션으로부터 데이를 가져가서 처리하고 이 파티션의 어느 레코드까지 가져갔는지 확인하기 위한 **오프셋**을 커밋한다.

커밋한 오프셋은 `__consumer_offsets` 토픽에 저장된다.

### 코디네이터

클러스터의 브로커 중 한대는 코디네이터 역할을 수행한다.

코디네이터는 컨슈머 그룹의 상태를 체크하고 파티션을 컨슈머와 매칭되도록 분배하는 역할을 한다.

컨슈머가 그룹에서 빠지면 매칭되지 않은 파티션을 나머지 컨슈머로 할당하여 끈임없이 데이터가 처리되도록 하는데 이를 **리밸런싱**이라 부른다.

### 주키퍼

주키퍼는 카프카의 메타데이터를 관리하는데 사용된다.

주키퍼에서 다수의 카프카 클러스터를 사용하려면 서로 다른 주키퍼의 `znode`에 클러스터들을 설정하면 된다.

`znode`는 주키퍼에서 사용되는 데이터 저장 단위이다.

`znode`가에 계층 구조를 가지며 1개의 `znode`에는 n개의 하위 `znode`가 존재할 수 있다.

2개 이상의 카프카 클러스터를 구축할 때는 `root znode`가 아닌 한 단계 아래의 `znode`를 카프카 브로커 옵션으로 저장한다.

### 토픽과 파티션

토픽은 카프카에서 데이터를 구분하기 위해 사용되는 단위이다.

토픽은 1개 이상의 파티션을 소유하고 파티션에는 프로듀서가 보낸 데이터들이 들어가는데 이 데이터를 **레코드**라 부른다.

파티션은 그룹으로 묶인 컨슈머들이 레코드를 병렬로 처리할 수 있도록 매칭된다.

컨슈머 개수를 늘림과 동시에 파티션 개수도 늘리면 처리량이 증가하는 효과를 볼 수 있다.

파티션은 `queue`와 비슷한 구조인데 먼저 들어간 레코드는 컨슈머가 먼저 가져가게 된다.

다만 `queue`와는 다르게 컨슈머가 레코드를 가져가도 삭제되지 않는다.

이러한 특징 때문에 다양한 목적을 가진 컨슈머 그룹들이 토픽을 여러번 가져갈 수 있다.

### 토픽 이름 제약 조건

- 빈 문자열 토픽 이름은 지원하지 않는다
- 토픽 이름은 `.` 또는 `..` 로 생성될 수 없다.
- 길이는 249자 미만으로 생성되어야 한다.
- 영어대소문자, 0 ~ 9, `.` , `_` , `-` 조합으로 생성할 수 있다.
- 냐부 로직 관리 목적으로 사용되는 2개의 토픽과 동일한 이름으로는 생성 불가능하다.
- 이름에 `.` 와 `-` 가 동시에 들어가면 안된다.
- 이미 생성된 이름의 `.` 를 `_` 로 바꾸거나 `_` 를 `.` 로 바꾼 경우 신규 토픽 이름과 동일하다면 생성할 수 없다. `to.pic`이 있다면 `to_pic`을 생성할 수 없다.

토픽의 이름을 보고도 어떤 용도로 어떤 환경에서 사용하는지 알 수 있도록 만드는게 좋다.

ex) <환경>.<팀명>.<애플리케이션명>.<메세지-타입>
ex) <환경>.<서비스명>.<JIRA 번호>.<메시지타입>

### 레코드

레코드는 타임스탬프, 메시지 키, 메시지 값, 오프셋, 헤더로 구성되어 있다.

프로듀서가 생성한 레코드가 브로커로 전송되면 오프셋과 타임스탬프가 지정되어 저장된다.

타임스탬프는 프로듀서에서 임의의 값을 설정할 수 있고, 토픽 설정에 따라 브로커에 적재된 시간으로 설정될 수 있다.

브로커에 한번 적재된 레코드는 수정할 수 없고 로그 리텐션 기간 또는 용량에 따라서만 삭제된다.

메시지 키를 사용하면 메시지 키의 해시값을 토대로 파티션을 저장하게 된다.

동일한 메시지 키라면 동일 파티션에 들어가게 된다.

다만, 어느 파티션에 지정될지 알 수 없고, 파티션 개수가 변경되면 메시지 키와 파티션 매칭이 달라지게된다.

메시지 키를 설정하지 않으면 프로듀서 기본 설정 파티셔너에 따라서 파티션에 분배된다.

메시지 값에는 실질적으로 처리할 데이터가 들어있다.

직렬화되어 전송되기 떄문에 컨슈머에서는 역직렬화를 반드시 직렬화와 동일한 형태로 처리해야한다.

오프셋은 0이상의 숫자로 이루어져 있다.

오프셋은 직접 지정할 수 없고 이전에 전송된 레코드의 오프셋 + 1 값으로 생성된다.

오프셋은 카프카 컨슈머가 데이터를 가져갈 때 사용되고 컨슈머들이 파티션의 데이터를 어디까지 가져갔는지 명확히 지정할 수 있다.

헤더는 레코드의 추가적인 정볼르 담는 메타데이터 저장소 용도로 사용한다.

헤더는 키 / 값 형태로 데이터를 추가하여 레코드의 속성을 저장하여 컨슈머에서 참조할 수 있다.

---

### 카프카 클라이언트

카프카 클라이언트는 **라이브러리**이기 떄문에 자체 라이프사이클을 가진 프레임워크나 애플리케이션 위에서 구현하고 실행한다.

### 프로듀서 API

프로듀서 애플리케이션은 카프카에 필요한 데이터를 선언하고 브로커의 특정 **토픽**의 파티션에 전송한다.

데이터를 전송할 때 **리더 파티션**을 가지고 있는 카프카 브로커와 직접 통신한다.

프로듀서는 데이터를 직렬화하여 카프카 브로커로 보내기 때문에 자바에서 선언 가능한 모든 형태를 브로커로 전송할 수 있다.

### 프로듀서 중요 개념

카프카 브로커로 데이터를 전송할 때 내부적으로 파티셔너, 배치 생성 단계를 거친다.

자바 애플리케이션에서 `KafkaProducer` 인스턴스를 생성할 때 파티셔너를 따로 설정하지 않으면 `DefaultPartitioner`로 설정된다.

파티셔너에서 구분된 레코드는 데이터를 전송하기 전에 **어큐뮬레이터** 에 **데이터를 버퍼로 쌓아놓고 발송한다.**

버퍼로 쌓인 데이터는 배치로 묶어서 전송하기 때문에 카프카의 프로듀서 처리량을 향상시키는 데에 상당한 도움을 준다.

프로듀서 API 를 사용하면 `UniformStikyPartitioner` 와 `RoundRobinPartitioner` 2개 파티션을 제공한다.

- `RoundRobinPartitioner`: 레코드가 들어오는 대로 파티션을 순회하면서 전송하기 때문에 배치로 묶이는 빈도가 적다.
- `UniformStikyPartitioner`: 프로듀서 동작에 특화되어 높은 처리량과 낮은 리소스 사용률을 가진다. 어큐뮬레이텨에서 데이터가 배치로 묶일 때까지 기다렸다가 배치로 묶인 데이터를 모두 동일한 파티션으로 전송한다.

`RoundRobinPartitioner` 보다 `UniformStikyPartitioner` 가 향상된 성능을 가지고 카프카 2.4.0버전부터 기본 파티셔너로 설정된다.

센더 스레드는 어큐뮬레이터에 쌓인 배치 데이터를 가져가 카프카 브로커로 전송한다.

카프카 프로듀서는 압축 옵션을 통해 브로커로 전송 시 압축 방식을 정할 수 있다.

압축을 하면 네트워크 처리량에서 이득을 보지만 CPU 또는 메모리 리소스를 사용하게 된다.

반대로 컨슈머에서 압축을 풀 때 리소스가 사용되기 떄문에 주의해야한다.

### 프로듀서 옵션

- `ack`: 데이터가 브로커들에 정상적으로 저장되었는지 전송 성공 여부를 확인할 때 사용

  - 0, 1, -1(all) 중 하나로 설정
  - 1: 리더 파티션에 데이터가 저장되면 성공으로 판단
  - 0: 프로듀서가 전송한 즉시 브로커에 데이터 저장 여부와 상관없이 성공으로 판단
  - -1: `min.insync.replicas` 개수에 해당하는 리더 파티션과 팔로워 파티션에 데이터가 저장되면 성공으로 판단

- `buffer.memory`: 브로커로 전송할 데이터를 배치로 모으기 위해 설정할 버퍼 메모리양 (기본 32MB)
- `retries`: 프로듀서가 브로커로부터 에러를 받고 난 뒤 재전송을 시도하는 횟수
- `batch.size`: 배치로 전송할 레코드 최대 용량
- `liger.ms`: 배치를 전송하기 전까지 기다리는 최소 시간
- `partitioner.class`: 레코드를 파티션에 전송할 때 적용하는 파티셔너 클래스
- `enable.idempotence`: 멱등성 프로듀서로 동작할지 여부
- `transactional.id`: 프로듀서가 레코드를 전송할 때 레코드를 트랜잭션 단위로 묶을지 여부
  - 이 값을 설정하면 트랜잭션 프로듀서로 동작

### 컨슈머 API

컨슈머는 적재된 데이터를 사용하기 위해 브로커로부터 데이터를 가져와서 필요한 처리를 한다.

### 컨슈머 중요 개념

토픽의 파티션으로부터 데이터를 가져가기 위해 컨슈머를 운영하는 방법은 2가지가 있다.

- 컨슈머 그룹
- 토픽의 특정 파티션만 구독하는 컨슈머

### 컨슈머 그룹

컨슈머 그룹 운영은 각 컨슈머 그룹으로부터 격리된 환경에서 안전하게 운영할 수 있도록 도와주는 카프카의 독특한 방식이다.

컨슈머 그룹으로 묶인 컨슈머들은 토픽의 1개 이상 파티션들에 할당되어 데이터를 가져갈 수 있다.

이 때 **1개의 파티션**은 **최대 1개의 컨슈머에 할당** 가능하다.

**1개의 컨슈머는 여러 개의 파티션에 할당될 수 있다.**

**컨슈머 그룹의 컨슈머 개수는 가져가고자 하는 토픽의 파티션 개수보다 같거나 작아야한다.**

파티션보다 많은 컨슈머가 있다면 파티션을 할당받지 못해 불필요한 스레드로 남게된다.

컨슈머 그룹은 다른 컨슈머 그룹과 **격리**되는 특징을 가지고 있다.

따라서 각기 다른 역할을 하는 컨슈머 그룹끼리 영향을 받지 않게 데이터를 처리할 수 있다.
