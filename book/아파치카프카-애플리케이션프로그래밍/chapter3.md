## 카프카 기본 개념 설명

---

### 카프카 브로커 . 클러스터 . 주키퍼

카프카 브로커는 카프카 클라이언트와 데이터를 주고받기 위해 사용하는 주체이자, 데이터를 분산 저장하여 장애가 발생하더라도 안전하게 사용할 수 있도록 도와주는 애플리케이션이다.

하나의 서버에는 한 개의 카프카 브로커 프로세스가 실행된다.

보통 브로커 서버 1대로도 실행이 가능하지만 데이터를 안전하게 보관하기 위해서 3대 이상의 브로커 서버를 1개의 **클러스터**로 묶어 운영한다.

클러스터로 묶인 브로커들은 프로듀서가 보낸 데이터를 안전하게 분산 저장하고 복제하는 역할을 수행한다.

### 데이터 저장, 전송

프로듀서로부터 데이터를 전달받으면 카프카브로커는 프로듀서가 요청한 토픽의 파티션에 데이터를 저장하고, 컨슈머가 데이터를 요청하면 파티션에 저장된 데이터를 전달한다.

**프로듀서로부터 전달된 데이터는 파일시스템에 저장된다.**

카프카는 **페이지 캐시**를 사용하여 디스크 입출력 속도를 높인다.

페이지 캐시란 **OS에서 파일 입출력의 성능 향상을 위해 만들어 놓은 메모리 영역**이다.

한번 읽은 파일의 내용은 메모리의 페이지 캐시 영역에 저장되고 나중에 동일한 파일의 접근이 일어나면 메모리에서 직접 읽는 방식이다.

페이지 캐시를 이용하지 않으면 **JVM** 위에서 동작하는 카프카 브로커에서 빠른 속도를 기대하기 어려웠을 것이다.

이러한 특징 떄문에 카프카 브로커를 실행하는데 **힙 메모리** 사이즈를 크게 설정할 필요가 없다.

### 데이터 복제, 싱크

데이터 복제는 카프카를 장애 허용 시스템으로 동작하도록하는 원동력이다.

클러스터로 묶인 브로커 중 일부에 장애가 발생하더라도 데이터를 유실하지 않고 안전하게 사용할 수 있다.

데이터 복제는 **파티션 단위**로 이루어지고, 토픽 생성시 파티션의 복제 개수도 같이 설정할 수 있다.

최솟값은 1이고 최댓값은 브로커 개수만큼 설정할 수 있다.

복제된 파티션은 **리더**와 **팔로워**로 구성된다.

- 리더: 프로듀서, 컨슈머와 직접 통신하는 파티션
- 팔로워: 복제 데이터를 가지고 있는 파티션

팔로워 파티션들은 리더 파티션의 오프셋을 확인하여 현재 자신이 가지고 있는 오프셋과 차이가 나는 경우 리더 파티션의 데이터를 복제한다.

파티션 복제로인해 복제 개수만큼의 용량이 증가된다는 단점이 있다.

안전하게 사용할 수 있다는 장점 떄문에 카프카 운영시 2 이상의 복제 개수를 정하는 것이 중요하다.

만약 브로커가 다운되면 해당 브로커에 있는 리더 파티션의 지위는 팔로워 파티션 중 하나가 넘겨받는다.

복제 갯수를 3으로 설정한다면 최대 2개의 브로커에서 동시 장애가 발생해도 데이터를 안전하게 유지할 수 있다.

### 컨트롤러

클러스터의 브로커 중 한대가 컨트롤러 역할을 한다.

컨트롤러는 다른 브로커의 상태를 체크하고 브로커가 클러스터에서 빠지는 경우 해당 브로커에 존재하는 리더 파티션을 재분배한다.

컨트롤러 브로커에서 장애가 발생하면 다른 브로커가 컨트롤러 역할을 대신한다.

### 데이터 삭제

카프카는 컨슈머가 데이터를 가져가더라도 토픽의 데이터를 삭제하지 않는다.

컨슈머나 프로듀서가 데이터 삭제를 요청할 수도 없다.

**브로커만이 데이터를 삭제할 수 있다.**

데이터 삭제는 파일 단위로 이루어지고, 이 단위를 **로그 세그먼트**라 부른다.

세그먼트는 특정 데이터를 선별해 삭제할 수 없고, 데이터가 쌓이는 동안 파일 시스템으로 열려있다.

브로커에 `log.segement.bytes` 또는 `log.segement.ms` 값이 설정되면 세그먼트 파일이 닫힌다.

세그먼트 파일이 닫히는 기본값은 `1GB` 용량에 도달했을 때이다.

닫힌 세그먼트 파일은 `log.segement.bytes` 또는 `log.segement.ms` 옵션에 설정값이 넘으면 삭제된다.

닫힌 세그먼트 파일을 체크하는 간격은 `log.retenstion.check.interval.ms` 에 설정된 값에 따른다.

### 컨슈머 오프셋 저장

컨슈머 그룹은 토픽이 특정 파티션으로부터 데이를 가져가서 처리하고 이 파티션의 어느 레코드까지 가져갔는지 확인하기 위한 **오프셋**을 커밋한다.

커밋한 오프셋은 `__consumer_offsets` 토픽에 저장된다.

### 코디네이터

클러스터의 브로커 중 한대는 코디네이터 역할을 수행한다.

코디네이터는 컨슈머 그룹의 상태를 체크하고 파티션을 컨슈머와 매칭되도록 분배하는 역할을 한다.

컨슈머가 그룹에서 빠지면 매칭되지 않은 파티션을 나머지 컨슈머로 할당하여 끈임없이 데이터가 처리되도록 하는데 이를 **리밸런싱**이라 부른다.

### 주키퍼

주키퍼는 카프카의 메타데이터를 관리하는데 사용된다.

주키퍼에서 다수의 카프카 클러스터를 사용하려면 서로 다른 주키퍼의 `znode`에 클러스터들을 설정하면 된다.

`znode`는 주키퍼에서 사용되는 데이터 저장 단위이다.

`znode`가에 계층 구조를 가지며 1개의 `znode`에는 n개의 하위 `znode`가 존재할 수 있다.

2개 이상의 카프카 클러스터를 구축할 때는 `root znode`가 아닌 한 단계 아래의 `znode`를 카프카 브로커 옵션으로 저장한다.

### 토픽과 파티션

토픽은 카프카에서 데이터를 구분하기 위해 사용되는 단위이다.

토픽은 1개 이상의 파티션을 소유하고 파티션에는 프로듀서가 보낸 데이터들이 들어가는데 이 데이터를 **레코드**라 부른다.

파티션은 그룹으로 묶인 컨슈머들이 레코드를 병렬로 처리할 수 있도록 매칭된다.

컨슈머 개수를 늘림과 동시에 파티션 개수도 늘리면 처리량이 증가하는 효과를 볼 수 있다.

파티션은 `queue`와 비슷한 구조인데 먼저 들어간 레코드는 컨슈머가 먼저 가져가게 된다.

다만 `queue`와는 다르게 컨슈머가 레코드를 가져가도 삭제되지 않는다.

이러한 특징 때문에 다양한 목적을 가진 컨슈머 그룹들이 토픽을 여러번 가져갈 수 있다.

### 토픽 이름 제약 조건

- 빈 문자열 토픽 이름은 지원하지 않는다
- 토픽 이름은 `.` 또는 `..` 로 생성될 수 없다.
- 길이는 249자 미만으로 생성되어야 한다.
- 영어대소문자, 0 ~ 9, `.` , `_` , `-` 조합으로 생성할 수 있다.
- 냐부 로직 관리 목적으로 사용되는 2개의 토픽과 동일한 이름으로는 생성 불가능하다.
- 이름에 `.` 와 `-` 가 동시에 들어가면 안된다.
- 이미 생성된 이름의 `.` 를 `_` 로 바꾸거나 `_` 를 `.` 로 바꾼 경우 신규 토픽 이름과 동일하다면 생성할 수 없다. `to.pic`이 있다면 `to_pic`을 생성할 수 없다.

토픽의 이름을 보고도 어떤 용도로 어떤 환경에서 사용하는지 알 수 있도록 만드는게 좋다.

ex) <환경>.<팀명>.<애플리케이션명>.<메세지-타입>
ex) <환경>.<서비스명>.<JIRA 번호>.<메시지타입>

### 레코드

레코드는 타임스탬프, 메시지 키, 메시지 값, 오프셋, 헤더로 구성되어 있다.

프로듀서가 생성한 레코드가 브로커로 전송되면 오프셋과 타임스탬프가 지정되어 저장된다.

타임스탬프는 프로듀서에서 임의의 값을 설정할 수 있고, 토픽 설정에 따라 브로커에 적재된 시간으로 설정될 수 있다.

브로커에 한번 적재된 레코드는 수정할 수 없고 로그 리텐션 기간 또는 용량에 따라서만 삭제된다.

메시지 키를 사용하면 메시지 키의 해시값을 토대로 파티션을 저장하게 된다.

동일한 메시지 키라면 동일 파티션에 들어가게 된다.

다만, 어느 파티션에 지정될지 알 수 없고, 파티션 개수가 변경되면 메시지 키와 파티션 매칭이 달라지게된다.

메시지 키를 설정하지 않으면 프로듀서 기본 설정 파티셔너에 따라서 파티션에 분배된다.

메시지 값에는 실질적으로 처리할 데이터가 들어있다.

직렬화되어 전송되기 떄문에 컨슈머에서는 역직렬화를 반드시 직렬화와 동일한 형태로 처리해야한다.

오프셋은 0이상의 숫자로 이루어져 있다.

오프셋은 직접 지정할 수 없고 이전에 전송된 레코드의 오프셋 + 1 값으로 생성된다.
