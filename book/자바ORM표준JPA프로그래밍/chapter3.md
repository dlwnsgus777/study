## 영속성 관리

---

JPA가 제공하는 기능은 크게 두가지이다.

- 엔티티와 테이블을 매핑하는 설계 부분
- 매핑한 엔티티를 실제 사용하는 부분

매핑한 엔티티는 **엔티티 매니저**를 통해 사용한다.

- 엔티티 매니저: 엔티티를 저장, 수정, 삭제, 조회 등 엔티티와 관련된 모든 일을 처리한다.

### 엔티티 매니저 팩토리와 엔티티 매니저

데이터 베이스를 하나만 사용하는 애플리케이션은 일반적으로 `EntityManagerFactory`를 하나만 생성한다.

```java
// 비용이 아주 많이든다.
final EntityManagerFactory emf = Persistence.createEntityManagerFactory("jpabook");
```

`Persistence.createEntityManagerFactory("jpabook")`를 호출하면 설정 정보를 바탕으로 `EntityManagerFactory` 를 생성한다.

그 후 엔티티 매니저 팩토리에서 엔티티 매니저를 생성하면 된다.

```java
// 팩토리에서 매니저 생성, 비용이 거의 안듬
final EntityManager em = emf.createEntityManager();
```

엔티티 매니저 팩토리는 **엔티티 매니저를 생성하는 공장** 이다.

팩토리를 생성할 때 드는 비용은 상당히 크기 때문에 한 개만 만들어 애플리케이션 전체에서 공유하도록 설계되어있다.

팩토리에서 매니저를 생성하는 비용은 **거의 들지 않는다.**

**팩토리는 여러 스레드가 동시에 접근해도 안전하므로 스레드 간에 공유가 가능하다.**

**매니저는 여러 스레드가 동시에 접근하면 동시성 문제가 발생하기 때문에 스레드 간에 절대 공유하면 안된다.**

엔티티 매니저는 데이터 베이스 연결이 꼭 필요한 시점까지 커넥션을 얻지 않는다.

보통 트랜잭션을 시작할 때 커넥션을 획득한다.

JPA 구현체들은 팩토리를 생성할 때 **커넥션 풀** 도 만든다.


### 영속성 컨텍스트란?

영속성 컨텍스트는 **엔티티를 영구 저장하는 환경**이다.

엔티티 매니저로 엔티티를 저장하거나 조회하면 엔티티 매니저는 영속성 컨텍스트에 엔티티를 보관하고 관리한다.

```java
em.persist(member);
```

`persist` 메소드는 엔티티 매니저를 사용해 회원 엔티티를 **영속성 컨텍스트에 저장**한다.

영속성 컨텍스트는 엔티티 매니저를 생성할 때 하나 만들어진다.

매니저를 통해 영속성 컨텍스트에 접근할 수 있고, 영속성 컨텍스트를 관리할 수 있다.

### 엔티티의 생명주기

엔티티에는 4가지 상태가 존재한다.

- 비영속 : 영속성 컨텍스트와 전혀 관계가 없는 상태
- 영속 : 영속성 컨텍스트에 저장된 상태
- 준영속 : 영속성 컨텍스트에 저장되었다가 분리된 상태
- 삭제 : 삭제된 상태

### 비영속 

엔티티 객체를 생성한 상태.

아직은 순수한 객체 상태이며 영속성 컨텍스트나 데이터 베이스와는 전혀 관련이 없다.

```java
    // 비영속 상태 - 객체를 생성한 상태
    Member member = new Member();
    member.setName("test");
```

### 영속

엔티티 매니저를 통해 엔티티를 영속성 컨텍스트에 저장한 상태

**영속성 컨텍스트가 관리하는 엔티티를 영속 상태**라고 한다.

영속 상태는 영속성 컨텍스트에 의해 관리된다는 뜻이다.

`em.find`나 `JPQL`을 사용해서 조회한 엔티티도 영속성 컨텍스트가 관리하는 영속 상태다.

```java
    // 비영속 상태 - 객체를 생성한 상태
    Member member = new Member();
    member.setName("test");

    // 영속 상태 - 엔티티 매니저를 통해 영속성 컨텍스트에 저장한 상태
    em.persist(member);
```

### 준영속

영속성 컨텍스트가 관리하던 영속 상태의 엔티티를 영속성 컨텍스트가 관리하지 않으면 **준영속 상태**가 된다.

특정 엔티티를 준영속 상태로 만들려면 `em.detach()`를 호출하면 된다.

`em.close()`를 호출해서 영속성 컨텍스트를 닫거나 `em.clear()`를 호출해서 영속성 컨텍스트를 초기화해도 영속 상태의 엔티티는 준영속 상태가 된다.

```java
    // 비영속 상태 - 객체를 생성한 상태
    Member member = new Member();
    member.setName("test");

    // 영속 상태 - 엔티티 매니저를 통해 영속성 컨텍스트에 저장한 상태
    em.persist(member);
    
    // 준영속 상태 - 엔티티를 영속성 컨텍스트에서 분리한 상태
    em.detach(member);
    em.close();
    em.clear();
```

### 삭제

엔티티를 영속성 컨텍스트와 데이터 베이스에서 삭제한다.

```java
    // 비영속 상태 - 객체를 생성한 상태
    Member member = new Member();
    member.setName("test");

    // 영속 상태 - 엔티티 매니저를 통해 영속성 컨텍스트에 저장한 상태
    em.persist(member);

    // 준영속 상태 - 엔티티를 영속성 컨텍스트에서 분리한 상태
    em.detach(member);
    em.close();
    em.clear();
    
    // 삭제 - 객체를 삭제한 상태
    em.remove(member);
```

### 영속성 컨텍스트의 특징

영속성 컨텍스트의 특징은 다음과 같다.

- 영속성 컨텍스트와 식별자 값
  - 영속성 컨텍스트는 엔티티를 식별자 값(@Id)으로 구분한다.
  - 영속 상태는 반드시 식별자 값이 있어야 한다.
- 영속성 컨텍스트와 데이터베이스 저장
  - 영속성 컨텍스트에 엔티티를 저장하면 트랜잭션을 커밋하는 순간 새로 저장된 엔티티를 데이터베이스에 반영한다. 
  - 이것을 Flush라고 한다.
- 영속성 컨텍스트가 엔티티를 관리하면 다음과 같은 장점이 있다.
  - 1차 캐시
  - 동일성 보장
  - 트랜잭션을 지원하는 쓰기 지연
  - 변경 감지
  - 지연 로딩

### 엔티티 조회

영속성 컨텍스트는 내부에 캐시를 가지고 있는데 이를 **1차 캐시**라 한다.

엔티티는 모두 이곳에 저장된다.

