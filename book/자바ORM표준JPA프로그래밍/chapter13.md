
## 웹 애플리케이션과 영속성 관리

---

스프링이나 J2EE 컨테이너 환경에서 JPA를 사용하면 컨테이너가 트랜잭션과 영속성을 관리해주므로 애플리케이션을 쉽게 개발할 수 있다.

컨테이너 환경에서 동작하는 JPA의 내부 동작 방식을 이해하지 못하면 문제가 발생했을 떄 해결하기가 쉽지 않다.

컨테이너 환경에서 JPA가 동작하는 방식을 이해하고 다양한 문제점과 해결 방안을 알아본다.

### 트랜잭션 범위의 영속성 컨텍스트

스프링 컨테이너 환경에서 JPA를 사용하면 컨테이너가 제공하는 전략을 따라야 한다.

### 스프링 컨테이너의 기본 전략

스프링 컨테이너는 트랜잭션 범위의 영속성 컨텍스트 전략을 기본으로 사용한다.

**트랜잭션의 범위와 영속성 컨텍스트의 생존 범위가 같다**는 뜻이다.

트랜잭션을 시작할 때 영속성 컨텍스트를 생성하고 트랜잭션이 끝날 때 영속성 컨텍스트를 종료한다.

같은 트랜잭션 안에서는 항상 같은 영속성 컨텍스트에 접근한다.

`@Transactional`을 선언하면해당 메서드를 호출하기 직전에 트랜잭션을 시작하고 메서드가 정상 종료되면 트랜잭션을 커밋하면서 종료한다.

트랜잭션을 커밋하면 JPA는 영속성 컨텍스트를 플러시한다.

만약 예외가 발생하면 트랜잭션을 롤백하고 종료하는데 이때는 **플러시를 호출하지 않는다.**

서비스 메서드가 끝나면서 컨트롤러에 전달된 엔티티는 **준영속 상태**이다.

### 트랜잭션이 같으면 같은 영속성 컨텍스트를 사용한다.

트랜잭션 범위의 영속성 컨텍스트 전략은 다양한 위치에서 엔티티 매니저를 주입받아 사용해도 

**트랜잭션이 같으면 항상 같은 영속성 컨텍스트를 사용한다.**

### 트랜잭션이 다르면 다른 영속성 컨텍스트를 사용한다.

여러 스레드에 동시에 요청이 와서 같은 엔티티 매니저를 사용해도 **트랜잭션에 따라 접근하는 영속성 컨텍스트가 다르다.**

### 준영속 상태와 지연 로딩

보통 트랜잭션은 서비스 계층에서 시작하므로 서비스 계층이 끝나는 시점에 트랜잭션이 종료되면서 영속성 컨텍스트도 종료된다.

따라서 컨트롤러나 뷰 같은 프리젠테이션 계층에서는 준영속 상태가 된다.

따라서 변경 감지와 지연 로딩이 **동작하지 않는다.**

지연 로딩 시점에 예외가 발생하게 된다.

변경 감지 기능은 영속성 컨텍스트가 살아 있는 서비스 계층(트랜잭션 범위까지만) 동작한다.

단순히 데이터를 보여주기만 하는 프리젠테이션 계층에서 데이터를 변경하는 일은 거의 없다.

따라서 변경 감지 기능이 프리젠테이션 계층에서 동작하지 않는 것은 특별히 문제가 되지 않는다.

### 준영속 상태와 지연 로딩

준영속 상태는 지연 로딩 기능이 동작하지 않는다.

뷰를 렌더링할 때 연관된 엔티티도 함께 사용해야 하는데 연관된 엔티티를 지연 로딩으로 설정해 

아직 초기화하지 않은 프록시 객체를 사용하면 예외가 발생한다.

JPA 표준에어떤 문제가 발생하는지에 대해 정의하지 않아 지연 로딩 시도시 발생하는 문제는 구현체마다 다르다.

준영속 상태의 지연 로딩 문제를 해결하는 방법은 크게 2가지 이다.

- 뷰가 필요한 엔티티를 미리 로딩해두는 방법
- `OSIV`를 사용해 엔티티를 항상 영속 상태로 유지하는 방법

### 뷰가 필요한 엔티티를 미리 로딩해두는 방법

이 방법은 이름 그대로 영속성 컨텍스트가 살아 있을 때 뷰에 필요한 엔티티들을 미리 다 로딩하거나 초기화해서 반환하는 방법이다.

엔티티가 준영속 상태로 변해도 연관된 엔티티를 다 로딩해두어서 지연 로딩이 발생하지 않는다.

필요한 엔티티를 미리 로딩해두는 방법은 어디서 미리 로딩하느냐에 따라 3가지가 있다.

1. 글로벌 페치 전략 수정
2. JPQL 페치 조인
3. 강제로 초기화

### 글로벌 페치 전략 수정

글로벌 페치 전략을 지연 로딩에서 즉시 로딩으로 변경하는 방법이다.

```java
@Entity
public class Order {
    @Id
    @GeneratedValue
    private Long id;
    
    @ManyToOne(fetch = FetchType.EAGER) // 즉시 로딩 전략
    private Member member;
}
```

엔티티에 있는 fetch 타입을 변경하면 애플리케이션 전체에서 이 엔티티를 로딩할 때마다 해당 전략을 사용하므로 **글로벌 페치 전략**이라 한다.

엔티티 매니저로 주문 엔티티를 조회하면 연관된 `member` 엔티티도 항상 함께 로딩한다.

따라서 준영속 상태가 되어도 `member`를 사용할 수 있다.

글로벌 페치 전략을 즉시 로딩으로 설정하는 것은 2가지 단점이 있다.

- 사용하지 않는엔 엔티티를 로딩한다.

화면 B에서는 `order` 만 필요하고 `member`는 필요하지 않지만 즉시 로딩 전략으로 인해 사용하지 않는 `member`도 같이 조회하게 된다.

- N + 1 문제가 발생한다.
