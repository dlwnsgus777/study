## 도메인 주도 설계의 사실과 오해

---

최근 DDD가 유행처럼 다시 올라오고 있지만 본질을 이해하지 못하고 접근하는 경우가 많다.

대부분의 경우에는 DDD와 객체지향이 섞여있는 상황이다.
- 이게 나쁜 건 아니다.
- 실질적으로 객체지향과 DDD를 헷갈려한다.

DDD는 답이 없다.
- 해석의 영역이 많다.

결론적으로 DDD와 객체지향은 완전히 다르다.

### Part1

---

소프트웨어의 본질
- 그 소프트웨어의 사용자를 위해 도메인에 관련된 문제를 해결하는 능력

DDD는 사용자의 문제를 해결해야한다는 관점에서 시작함.
- 사용자의 문제를 해결해야하기 때문에 도메인에 포커스를 맞추어야한다는게 본질이다.

DDD는 에릭 에반스가 정의한 이름이다.
- DDD는 구현의 관점보다는 사고방식이다.
- 복잡한 도메인을 다뤄야하는 사고방식
  - 어디에 우선순위를 두어야할지에 대한 모음
- DDD는 도메인을 해결하기 위한 __패턴들의 집합체__

객체지향의 기반은 다음과 같다.
> 사용자의 요구사항을 위한 기능을 개발할 때 어떻게 기능을 나누고 배분을 하면 유지보수하기 편한 코드가 나온다

DDD는 더 광범위함
- 디자인 패턴과 비슷함
  - 어떤 문제가 있을 때는 이런 패턴으로 했을 때 문제가 더 단순해진다
- DDD는 선택적으로 사용하는 것
  - DDD는 패턴랭귀지

에릭에반스의 도메인주도설계
- 무슨 말인지 모르겠음
- 대부분은 `part2` 까지 일고 안읽음
- 이 책 이후에 나온 책들은 DDD의 많은 사상을 덜어냄
  - 도메인주도설계에 대한 해석의 영역

---

지금부터는 에릭에반스의 도메인주도설계에 대한 설명이다.

DDD를 얘기할 때에는 `part1`의 내용이 본질이다.

### Part1 

도메인 모델을 동작하게 만드는 것이 핵심.

단어를 하나씩 정리해보자.

도메인 모델
- 도메인 모델의 정의는 많다.
  - 바라보는 사람, 상황마다 다름

도메인
- 사용자가 프로그램을 사용하는 주제 영역
  - 우리가 소프트웨어를 만든다는 건 문제가 있다는 것
    - 불편함, 니즈 등등
  - 이 니즈를 해결하기 위해 소프트웨어를 만든다
    - 프로그램으로 어디서부터 어디까지 개발해야하는지를 정한다.
- 어떤 문제가 있을 때 여기서부터 여기까지 소프트웨어에 담을 것이다 -> 이것이 도메인
  - 이 도메인을 가지고 모델링을 하는게 도메인 모델

모델
- 대상의 단순화
- 당면한 문제를 해결하는 것과 관련된 측면을 추상화하고 중요하지 않은 부분은 생략
- 내가 문제를 풀 때 필요한 것만 가져오고 복잡한 것은 단순화

도메인 모델
- 여기서부터 여기까지는 프로그램에 넣을 것이다.
- 그 뒤 문제를 단순화 시켜서 정리한다.
  - 관련자들끼리 싱크를 맞춘다.
- 정해진 형식은 없다
  - 형태나 형식보다는 목적이 중요하다
  - 목적은 코드를 잘짜고 싶은 것
- 심플하고 공감되는 무언가를 보여줄 수 있으면 도메인 모델이다.

동작하는 
- 도메인 모델을 만들었으면 그걸 기반으로 설계하고 코드에 반영
- 코드가 바뀐다 -> 도메인의 개념이 바뀐다.
- 도메인 모델 = 코드
  - 내가 짠 코드가 도메인 모델이어야한다.
- 코드이기 때문에 실행이 가능해야한다. -> 동작하게 만든다.
- 코드를 바꾸면 도메인 모델이 바뀐 것
  - 도메인 모델이 바뀌면 코드도 바뀐다.
- 전부 없애고 코드만 남았을 때에도 코드를 보고 도메인을 설명할 수 있어야한다.

만들기
- 어떻게의 영역
- 도메인 모델을 만든다는 것 -> 코드를 만드는 것
  - 개발자가 도메인을 알 수 없다.
  - 도메인 전문가
    - 도메인에 대해서 결정을 내릴 수 있는 사람
  - 유비쿼터스 언어
    - 개발자와 도메인 전문가와의 언어에서 교집합을 만든 것
      - 소통하다보면 자연스럽게 만들어진다.
- 디자인이라는 건 코드를 잘 짜고 싶은 것
  - 코드를 바꿀 떄 변경하기 편하게 짜고 싶은 것 -> 모든 설계의 철학
  - 코드가 바뀌느 건 도메인이 바뀌는 것
    - 사업이 바뀌거나 등등
    - 도메인이 바뀌면 당연히 코드가 바뀜
      - 도메인이 바뀔 때 코드를 쉽게 변경하고 싶은게 목적
        - 객체지향은 작은 단위에서의 코드
        - DDD는 좀 더 큰 영역이다.

여기까지가 `part1`의 내용이다.

설계는 전부 가이드이고 결국 트레이드 오프를 하여 상황에 적절한 설계를 사용해야한다.

---

DDD는 지금 읽어보면 당연한 내용들이 많다.

하지만 DDD가 처음 나왔을 때에는 지금과는 상황이 많이 달랐다.

90년도 초 ~ 2000년 중반까지 어마어마하게 바뀐 시기
- 지금은 상식처럼 받아들여지는 모든게 그때에는 이상했다.
  - 대표적으로 리펙터링

DDD는 두가지를 기반으로 쌓아올림
- 객체지향
- 애자일

DDD는 객체지향은 아니다
- DDD는 사고방식과 우선순위이다.

기본적으로 DDD가 나온 시기에는 객체지향이 영향력을 펼치기 위한 시기이다.
- 그래서 DDD가 나온 원천은 객체지향 커뮤니티이다.

객체지향의 개념을 잘 표현한 건 사실 UI이다.
- 원래는 UI에서 사용하는 패러다임이다.
- 컴포넌트들이 객체와 잘맞았다.
- 클라이언트에서 서버로 가다보니 UI에 비즈니스 로직이 들어가게 되었다.

그 뒤에 웹이 나왔다.
- 브라우저는 보여주기만 하고 로직을 서버에 내리게 되었다.
  - 객체가 서버로 내려가게 됨
    - 이 때 서버 코드를 짤 때 객체지향을 적용하자라는 말이 나옴
  - 분산 객체 기술 -> 망함
    - 객체를 만들면 다른 시스템에 있는 객체와 통신하길 바랬음
    - 침투적인 아키텍쳐
      - 스프링의 인터페이스나 하이버네이트의 무언가를 도메인 객체에서 나오게하면 안된다.
    - 예전에는 뭔가를 만들려고하면 기술적인 스펙에 맞춰서 만들어야 했다.
      - 기술에 맞춰 요구사항을 끼워맞췄다.

2002년
- 기술적인 관심사와 도메인 관심사를 섞으면 유지보수하기 힘들다는 말이 나오기 시작
- `POJO`라는 말이 나옴
  - 아무것도 없이 메모리 상에서 만들 수 있는 객체

2023년
- DDD가 나옴
- 사람들이 생각하는 도메인과 우리가 짠 코드의 모습이 다름
  - 기술적인 것 다 덜어내고 우리가 생각하는 걸 코드로 구현해야 한다
- 기술적인 관심사와 도메인을 섞지 말자는 취지
  - 이걸 기술적으로 서포트하는게 나옴 
    - 스프링
- 기술적이 관심사가 도메인에 섞이면 언어가 바뀜
  - 타 직군과 의사소통하기 어려워짐

여기까지가 `part1`에 대한 내용

---

### Part2

`part2`는 도메인을 잘 표현하는 가이드
- 엔티티, VO

심플한 코드로 복잡한 도메인을 만들 수 있는 가이드
- 어떤 상황일 때 엔티티를 사용하고 어떤 상황일 때는 VO를 쓰는지가 핵심

DDD는 아키텍처를 정의하지 않음
- 어디에 끼워맞춰도 되지만 가이드가 없다.

본질은 도메인 레이어를 다른 레이어와 분리하는게 본질이다.

`part2`를 볼 때는 다음의 내용이다.
- 어떠한 문제가 있고
- 이 문제는 이렇게 만들면 
- 이 문제가 이렇게 단순하게 바뀐다

도메인 모데델을 코드로 짜기 위한 가이드 -> **법칙이 아니다**
- 현실적으로 전부 따라하는 건 불가능하다.

도메인을 표현하기 위해서는 다음이 필요하다.
- 어소시에이션
- 벨류 오브젝트
- 엔티티
- ...

도메인의 라이프싸이클을 표현하는 것은 어그리게이트이다.

DDD는 구현에 대한 가이들르 제공해서 복잡도를 낮추는 것이다.

`part2`에는 많은 빌딩 블록이 있다.

애그리거트 -> 집합으로 생각하지만 잘못된 생각이다.
- 집합으로 생각하면 애그리거트가 되게 커진다.

도메인에 문제가 있을 때 코드로 구현하려 할 때 **이런 문제가 발생하니 가이드를 제시**하는게 책의 일관된 내용

우리가 하는 일 
- 객체를 만들고 객체의 상태를 막 바꾸다가 어느 시점이 되면 삭제한다.

불변식
- 객체가 어떤 상황이든 무조건 꼭 지켜야하는 규칙
- 비즈니스룰

도메인을 가지고 개발한다는 것
- 비즈니스의 규칙 안에서 객체의 상태가 변경되는 것이 포함
- 이걸 어기면 버그다.

애그리게이트
- 불변식을 만족시키는 객체 그룹 단위로 처리
- 객체 하나만 가지고 불변식을 체크하는 일은 거의 없다.
- 객체를 하나씩 개별 수정하면 불변식이 깨질 수 있으니 **불변식에 따라 객체를 묶자**
  - 단순 `has a` 관계라고 생각하면 안됨
- 트랜잭션의 단위
  - 애그리게이트 단위로 트랜잭션의 단위를 잡아라
  - 불변식을 만족시키기 위해
- 애그리게이트는 저장의 단위
  - 애그리게이트 단위로 리포지토리 추가
- 복잡성 감소를 위한 ID를 이용한 참조