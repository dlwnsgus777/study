## 도메인 주도 설계의 사실과 오해 - Part1

---


최근 DDD가 유행처럼 다시 올라오고 있지만 본질을 이해하지 못하고 접근하는 경우가 많다.

대부분의 경우에는 DDD와 객체지향이 섞여있는 상황이다.
- 이게 나쁜 건 아니다.
- 실질적으로 객체지향과 DDD를 헷갈려한다.

DDD는 답이 없다.
- 해석의 영역이 많다.

결론적으로 DDD와 객체지향은 완전히 다르다.

### Part1

---

소프트웨어의 본질
- 그 소프트웨어의 사용자를 위해 도메인에 관련된 문제를 해결하는 능력

DDD는 사용자의 문제를 해결해야한다는 관점에서 시작함.
- 사용자의 문제를 해결해야하기 때문에 도메인에 포커스를 맞추어야한다는게 본질이다.

DDD는 에릭 에반스가 정의한 이름이다.
- DDD는 구현의 관점보다는 사고방식이다.
- 복잡한 도메인을 다뤄야하는 사고방식
  - 어디에 우선순위를 두어야할지에 대한 모음
- DDD는 도메인을 해결하기 위한 __패턴들의 집합체__

객체지향의 기반은 다음과 같다.
> 사용자의 요구사항을 위한 기능을 개발할 때 어떻게 기능을 나누고 배분을 하면 유지보수하기 편한 코드가 나온다

DDD는 더 광범위함
- 디자인 패턴과 비슷함
  - 어떤 문제가 있을 때는 이런 패턴으로 했을 때 문제가 더 단순해진다
- DDD는 선택적으로 사용하는 것
  - DDD는 패턴랭귀지

에릭에반스의 도메인주도설계
- 무슨 말인지 모르겠음
- 대부분은 `part2` 까지 일고 안읽음
- 이 책 이후에 나온 책들은 DDD의 많은 사상을 덜어냄
  - 도메인주도설계에 대한 해석의 영역

---

지금부터는 에릭에반스의 도메인주도설계에 대한 설명이다.

DDD를 얘기할 때에는 `part1`의 내용이 본질이다.

### Part1 

도메인 모델을 동작하게 만드는 것이 핵심.

단어를 하나씩 정리해보자.

도메인 모델
- 도메인 모델의 정의는 많다.
  - 바라보는 사람, 상황마다 다름

도메인
- 사용자가 프로그램을 사용하는 주제 영역
  - 우리가 소프트웨어를 만든다는 건 문제가 있다는 것
    - 불편함, 니즈 등등
  - 이 니즈를 해결하기 위해 소프트웨어를 만든다
    - 프로그램으로 어디서부터 어디까지 개발해야하는지를 정한다.
- 어떤 문제가 있을 때 여기서부터 여기까지 소프트웨어에 담을 것이다 -> 이것이 도메인
  - 이 도메인을 가지고 모델링을 하는게 도메인 모델

모델
- 대상의 단순화
- 당면한 문제를 해결하는 것과 관련된 측면을 추상화하고 중요하지 않은 부분은 생략
- 내가 문제를 풀 때 필요한 것만 가져오고 복잡한 것은 단순화

도메인 모델
- 여기서부터 여기까지는 프로그램에 넣을 것이다.
- 그 뒤 문제를 단순화 시켜서 정리한다.
  - 관련자들끼리 싱크를 맞춘다.
- 정해진 형식은 없다
  - 형태나 형식보다는 목적이 중요하다
  - 목적은 코드를 잘짜고 싶은 것
- 심플하고 공감되는 무언가를 보여줄 수 있으면 도메인 모델이다.

동작하는 
- 도메인 모델을 만들었으면 그걸 기반으로 설계하고 코드에 반영
- 코드가 바뀐다 -> 도메인의 개념이 바뀐다.
- 도메인 모델 = 코드
  - 내가 짠 코드가 도메인 모델이어야한다.
- 코드이기 때문에 실행이 가능해야한다. -> 동작하게 만든다.
- 코드를 바꾸면 도메인 모델이 바뀐 것
  - 도메인 모델이 바뀌면 코드도 바뀐다.
- 전부 없애고 코드만 남았을 때에도 코드를 보고 도메인을 설명할 수 있어야한다.

만들기
- 어떻게의 영역
- 도메인 모델을 만든다는 것 -> 코드를 만드는 것
  - 개발자가 도메인을 알 수 없다.
  - 도메인 전문가
    - 도메인에 대해서 결정을 내릴 수 있는 사람
  - 유비쿼터스 언어
    - 개발자와 도메인 전문가와의 언어에서 교집합을 만든 것
      - 소통하다보면 자연스럽게 만들어진다.
- 디자인이라는 건 코드를 잘 짜고 싶은 것
  - 코드를 바꿀 떄 변경하기 편하게 짜고 싶은 것 -> 모든 설계의 철학
  - 코드가 바뀌느 건 도메인이 바뀌는 것
    - 사업이 바뀌거나 등등
    - 도메인이 바뀌면 당연히 코드가 바뀜
      - 도메인이 바뀔 때 코드를 쉽게 변경하고 싶은게 목적
        - 객체지향은 작은 단위에서의 코드
        - DDD는 좀 더 큰 영역이다.

여기까지가 `part1`의 내용이다.

설계는 전부 가이드이고 결국 트레이드 오프를 하여 상황에 적절한 설계를 사용해야한다.

---

DDD는 지금 읽어보면 당연한 내용들이 많다.

하지만 DDD가 처음 나왔을 때에는 지금과는 상황이 많이 달랐다.

90년도 초 ~ 2000년 중반까지 어마어마하게 바뀐 시기
- 지금은 상식처럼 받아들여지는 모든게 그때에는 이상했다.
  - 대표적으로 리펙터링

DDD는 두가지를 기반으로 쌓아올림
- 객체지향
- 애자일

DDD는 객체지향은 아니다
- DDD는 사고방식과 우선순위이다.

기본적으로 DDD가 나온 시기에는 객체지향이 영향력을 펼치기 위한 시기이다.
- 그래서 DDD가 나온 원천은 객체지향 커뮤니티이다.

객체지향의 개념을 잘 표현한 건 사실 UI이다.
- 원래는 UI에서 사용하는 패러다임이다.
- 컴포넌트들이 객체와 잘맞았다.
- 클라이언트에서 서버로 가다보니 UI에 비즈니스 로직이 들어가게 되었다.

그 뒤에 웹이 나왔다.
- 브라우저는 보여주기만 하고 로직을 서버에 내리게 되었다.
  - 객체가 서버로 내려가게 됨
    - 이 때 서버 코드를 짤 때 객체지향을 적용하자라는 말이 나옴
  - 분산 객체 기술 -> 망함
    - 객체를 만들면 다른 시스템에 있는 객체와 통신하길 바랬음
    - 침투적인 아키텍쳐
      - 스프링의 인터페이스나 하이버네이트의 무언가를 도메인 객체에서 나오게하면 안된다.
    - 예전에는 뭔가를 만들려고하면 기술적인 스펙에 맞춰서 만들어야 했다.
      - 기술에 맞춰 요구사항을 끼워맞췄다.

2002년
- 기술적인 관심사와 도메인 관심사를 섞으면 유지보수하기 힘들다는 말이 나오기 시작
- `POJO`라는 말이 나옴
  - 아무것도 없이 메모리 상에서 만들 수 있는 객체

2023년
- DDD가 나옴
- 사람들이 생각하는 도메인과 우리가 짠 코드의 모습이 다름
  - 기술적인 것 다 덜어내고 우리가 생각하는 걸 코드로 구현해야 한다
- 기술적인 관심사와 도메인을 섞지 말자는 취지
  - 이걸 기술적으로 서포트하는게 나옴 
    - 스프링
- 기술적이 관심사가 도메인에 섞이면 언어가 바뀜
  - 타 직군과 의사소통하기 어려워짐

여기까지가 `part1`에 대한 내용

---

### Part2

`part2`는 도메인을 잘 표현하는 가이드
- 엔티티, VO

심플한 코드로 복잡한 도메인을 만들 수 있는 가이드
- 어떤 상황일 때 엔티티를 사용하고 어떤 상황일 때는 VO를 쓰는지가 핵심

DDD는 아키텍처를 정의하지 않음
- 어디에 끼워맞춰도 되지만 가이드가 없다.

본질은 도메인 레이어를 다른 레이어와 분리하는게 본질이다.

`part2`를 볼 때는 다음의 내용이다.
- 어떠한 문제가 있고
- 이 문제는 이렇게 만들면 
- 이 문제가 이렇게 단순하게 바뀐다

도메인 모데델을 코드로 짜기 위한 가이드 -> **법칙이 아니다**
- 현실적으로 전부 따라하는 건 불가능하다.

도메인을 표현하기 위해서는 다음이 필요하다.
- 어소시에이션
- 벨류 오브젝트
- 엔티티
- ...

도메인의 라이프싸이클을 표현하는 것은 어그리게이트이다.

DDD는 구현에 대한 가이들르 제공해서 복잡도를 낮추는 것이다.

`part2`에는 많은 빌딩 블록이 있다.

애그리거트 -> 집합으로 생각하지만 잘못된 생각이다.
- 집합으로 생각하면 애그리거트가 되게 커진다.

도메인에 문제가 있을 때 코드로 구현하려 할 때 **이런 문제가 발생하니 가이드를 제시**하는게 책의 일관된 내용

우리가 하는 일 
- 객체를 만들고 객체의 상태를 막 바꾸다가 어느 시점이 되면 삭제한다.

불변식
- 객체가 어떤 상황이든 무조건 꼭 지켜야하는 규칙
- 비즈니스룰

도메인을 가지고 개발한다는 것
- 비즈니스의 규칙 안에서 객체의 상태가 변경되는 것이 포함
- 이걸 어기면 버그다.

애그리게이트
- 불변식을 만족시키는 객체 그룹 단위로 처리
- 객체 하나만 가지고 불변식을 체크하는 일은 거의 없다.
- 객체를 하나씩 개별 수정하면 불변식이 깨질 수 있으니 **불변식에 따라 객체를 묶자**
  - 단순 `has a` 관계라고 생각하면 안됨
- 트랜잭션의 단위
  - 애그리게이트 단위로 트랜잭션의 단위를 잡아라
  - 불변식을 만족시키기 위해
- 애그리게이트는 저장의 단위
  - 애그리게이트 단위로 리포지토리 추가
- 복잡성 감소를 위한 ID를 이용한 참조

트랜잭션 일관성
- 불변식
결과적 일관성
- 나중에 맞춰줘도 되는 것
- 애그리거트의 변화에 다른 애그리거트의 어떤 조건이 맞아야한다면 결과적 일관성으로 한다.
  - 불변식이 다르기 때문

트랜잭션 스크립트
- 비즈니스 로직을 절차지향적으로 짜는 것
도메인 모델 패턴
- 비즈니스 로직을 객체지향적으로 짜는 것
- 도메인 로직을 객체지향적으로 짜는 방식
  - DDD의 도메인 모델이랑은 다름

---

### Part3

Part3은 애자일과 관련이 있다.

조영호님이 신입 때는 두가지 고민이 있었다.
1. 늘 처음 생각과 짜여진 코드는 다르게 간다.
2. 일정을 제대로 추정하지 못한다.

본질적으로 __설계를 하고 설계대로 코드를 짜는 건 불가능__
- 일정 추정을 정확하게 하는 건 불가능하다.
  - 이거에 대한 해결법을 고민 -> 애자일의 시작

뭔가가 변하는데 그 변화에 맞게 대응하는 것 -> 애자일

그동안의 문제
1. 흐릿한 요구사항
   - 일정 추청을 못함
   - 중간에 요구사항을 바꿈
     - 설계된 대로 코드를 짤 수 없음
2. 설계를 먼저하라고 함
   - 설계 끝나고 개발하려고하면 요구사항이 다 바껴있음

소프트웨어는 건축에서 따온 개념들이 많다.

그 동안 일하는 방식은 건축에서 일하는 방식
  - 건축에서는 설계를 먼저한다.
  - 건축 중간에 요구사항을 변경할 수 없다.

우리는 본질적으로 건축의 방식이랑은 다르다
- 애자일의 시작

XP의 기본 -> **소프트웨어에서의 변경은 나쁜게 아니다**ㅁ
- 변경읠 최대한 수용할 수 있는 형태로 개발하자
- 반복을 통한 피드백
  - 일부를 먼저 개발한다.
- 요구사항이 흐릿한 건 당연하다.
- 모든 기능이 나가는 것이 아니라 정해진 날짜에 중요한 기능은 나갈 수 잇도록 하는 것
  - 피드백과 반복이 애자일의 핵심

리팩터링
- 설계를 바꿔나가는 것
  - 코드를 짜고 리팩터링한다는 건 피드백이 온다는 것이다.

`part3`에서는
- 어떠한 패턴을 사용하면 도메인이 명확해짐
  - 바뀔 때마다 쉽게 코드를 짤 수 있게 변경될 것
- DDD는 애자일 프로세스를 기반으로 돌아간다는 전제가 있음
- 도메인 주도 설계의 핵심은 도메인 모델의 리팩터링

DDD를 했는가 안했는가
- 비즈니스 룰을 어디에 녹일 것인가
- 계속 리팩터링을 하고 있는가?
- 도메인 모델을 꾸준히 리팩터링하고 있는가?

취지라는 것이 있음
- 이게 왜 좋은 건지
  - 반대로 어떤 경우에는 좋지 않다는 뜻

본래 취지와 동기를 아는 것과 그냥 따라하는 것은 다르다.

추상화는 설계 초반에 잡을 수 없다. 
- 단, 예전에 많이 해본 도메인이라면 가능하다.

추상화는 개발쪽에선 되게 안정적인 것
- 추상화는 바뀌면 안되는 것
  - 임플리멘테이션은 바뀌는 것(구현체는 바뀐다)

메서드의 시그니처는 추상화
- 메서드의 바디는 막 바뀐다.

코드를 짜다가 중복 코드를 발견하면 추상화가 발견된다.
- 추상화를 끄집어내서 인터페이스나 클래스로 만드는 작업을 한다.

유연한 설계는 코드를 바꾸고 리팩터링을 하다보면 나옴
- 리팩터링을 하다보면 어느 시점에는 코드를 쉽게 고칠 수 있는 시점이 옴

결국 `part3`는 리팩터링에 대한 이야기

---

## Part4

이 챕터에서 바운디드 컨테스트가 나온다.

현재는 MSA에 엮어서 얘기하는 경우가 많은데 잘못된 것이다.

애그리거트와 바운디드 컨텍스트가 MSA를 설명하게 좋다.
- 그래서 오해가 많이 생긴다.

애그리거트 -> 비즈니스 룰
- MSA와는 상관이 없음

모놀리틱으로 짜도 DDD를 하는 것이다.

`Part4`에서는 정치와 개발이 나온다.

우리는 우리 시스템의 도메인 모델을 하나로 만들어야 된다고 착각한다.
- 우리 시스템의 도메인 모델은 여러개여야 한다는 게 핵심

'도메인 모델의 중복을 막으려고 하면 망한다' 가 Part4의 내용

도메인 모델은 여러개가 있어야 한다.

중복은 변경이 어떻게 일어나는지 봐야한다.
- A를 바꿨을 때 B를 바꾸면 중복이다.

모든 장단점이 있고 적합할 때가 있으니 의미없이 따라가기만하면 안된다.

도메인 모델을 쓰는 컨텍스트를 제한하는 것 -> 바운디드 컨텍스트

코드를 여러개로 찢었지만 배포를 같이하면 모놀리식

모놀리식 단위더라도 코드들이 사용되는 영역을 제한 -> 바운디드 컨텍스트

바운디드 컨텍스트 -> 팀 단위로 쪼갠다.

전략적 디스틸레이션
- 우선순위
- 회사 차원에서의 우선순위
- 리소스를 집중할 영역과 시스템 구축 방법을 결정하는 것

코어 도메인
- 사업적으로 잘하려고 하는 도메인
  - 사업의 성공을 결정하는 도메인
- 코어 도메인은 바뀔 수 있다.

제네릭 서브도메인
- ERP 같은 것
- 기성 소프트웨어를 구입하거나 주니어 투입 등

지원 서브 도메인
- 외주로 해결하거나 개발자들의 성장을 위한 기회로 사용

현재의 DDD
- 서브 도메인 -> 이상적으로 해야했던 것
- 바운디드 컨텍스트 -> 우리 코드의 현실

지금의 DDD는 DDD 철학을 구현하는 자기들의 방법임.

생각보다 롤 상으로는 맞춰야할 것 같은데 아닌 경우가 많다.

이벤트 소싱
- 어떤 이벤트를 통해서 현재의 값이 나왔는지 확인할 때 **이벤트 소싱**을 쓴다.
  - 은행 계좌에서 착안됨
- 이벤트 소싱은 DB가 없다.

책임이 과도해진 도메인 모델
- DDD의 엔티티, 애그리거트 등등은 조회를 빼고 생각해야 한다.
- DDD가 말하는 건 수정할 때이다.
  - 수정을 생각하고 경계를 나눈다.
- `CQRS`로 나눈다.

헥사고날 아키텍쳐
- api 통신에 대응할 수 있는 아키텍쳐

도메인 중심으로 코드를 짜기 위해서 도메인 주도 설계와 도메인 중심 아키텍처가 나옴

예전에는 프레임워크에 기술적인 종속성을 강제하는 경우가 있었다.

우리가 원하는 건 DDD를 하는게 아니다.
- DDD라면 뭐든 좋다고 생각하는 건 좋지 않다.
- 환경을 못바꾸면 DDD의 몇가지 패턴을 가져다 사용하는게 좋다.
- DDD는 수단이다.
  - 코드를 더 잘짜기 위한

애그리거트는 가급적이면 작게하라.
- A가 끝나고 B를 해야하는데 불필요하게 들어가지 않게
  - 구조적으로 포함관계면 애그리거트다 -> 제일 안좋음

코드를 잘 짠다는 것 -> 우리팀도 일관적으로 짜는 것도 포함

객체는 그 상태를 자신이 처리
데이터는 그 데이터를 통해 다른 곳에서 처리


## 도메인 주도 설계의 사실과 오해 - Part2

- 강의 두 번쨰 시간에는 도메인주도설계의 구현부에 대한 내용을 주로 다룬다.
---

DDD의 코드라기 보다는 글로 되어있는 entity, VO 같은 건 이런 의미에오 라는 뜻
- 꼭 그렇게 짤 필요는 없음

도메인이나 비즈니스의 요구사항을 안따라가거나 의사소통을 하지 않는 건 DDD가 아니다.
- 혼자 코드만 짠다고 해서 DDD가 아님

강의 두 번째 시간에는 이러한 의사소통이나 비즈니스 요구사항을 잘 따라간다는 전제하에 진행한다.

DDD의 빌딩 블록을 통해 객체지향을 하는 것

강의의 내용은 객체지향을 짤 때 DDD의 빌딩블록 개념을 사용해 코드를 작성하는 것과 같다.

객체지향으로 짜는 데 어느 부분은 DDD를 곁들이는 것으로 진행

